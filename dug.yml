import pytest
import asyncio
from c1.genai.compound_ai.tools.tool import Tool
from c1.genai.compound_ai.tools.types import Scope

# Fixtures for single-parameter tests.
@pytest.fixture
def input_schema():
    return {
        "type": "object",
        "properties": {
            "x": {"type": "number", "scope": "public"}
        },
        "required": ["x"]
    }

@pytest.fixture
def output_schema():
    return {
        "type": "object",
        "properties": {
            "result": {"type": "number", "scope": "public"}
        },
        "required": ["result"]
    }

# Dummy synchronous function: doubles the input.
@pytest.fixture
def double_func():
    def double(x: float) -> dict:
        return {"result": x * 2}
    return double

# Dummy asynchronous function: doubles the input.
@pytest.fixture
def async_double():
    async def async_double(x: float) -> dict:
        return {"result": x * 2}
    return async_double

def test_invoke_valid(input_schema, output_schema, double_func):
    tool = Tool(
        name="double",
        description="Doubles a number",
        input_model=input_schema,
        output_model=output_schema,
        scope=Scope.PUBLIC,
        func=double_func
    )
    result = tool.invoke(x=5)
    assert result == {"result": 10}

def test_invoke_invalid_input(input_schema, output_schema, double_func):
    tool = Tool(
        name="double",
        description="Doubles a number",
        input_model=input_schema,
        output_model=output_schema,
        scope=Scope.PUBLIC,
        func=double_func
    )
    with pytest.raises(ValueError):
        tool.invoke(x="not a number")

def test_invoke_invalid_output(input_schema, output_schema):
    # Function returning output not matching schema.
    def bad_func(x: float) -> dict:
        return {"incorrect": x}
    
    tool = Tool(
        name="bad_tool",
        description="Returns invalid output",
        input_model=input_schema,
        output_model=output_schema,
        scope=Scope.PUBLIC,
        func=bad_func
    )
    with pytest.raises(ValueError):
        tool.invoke(x=5)

@pytest.mark.asyncio
async def test_ainvoke_valid(input_schema, output_schema, async_double):
    tool = Tool(
        name="async_double",
        description="Doubles a number asynchronously",
        input_model=input_schema,
        output_model=output_schema,
        scope=Scope.PUBLIC,
        coroutine=async_double
    )
    result = await tool.ainvoke(x=7)
    assert result == {"result": 14}

def test_rescope(input_schema, output_schema, double_func):
    tool = Tool(
        name="double",
        description="Doubles a number",
        input_model=input_schema,
        output_model=output_schema,
        scope=Scope.PUBLIC,
        func=double_func,
        default_inputs={"x": 1},
        default_outputs={"result": 2}
    )
    new_scope = Scope.PRIVATE
    new_tool = tool.rescope(new_scope, default_inputs={"x": 3}, default_outputs={"result": 6})
    assert new_tool.scope == new_scope
    assert new_tool.default_inputs == {"x": 3}
    assert new_tool.default_outputs == {"result": 6}

def test_partial_defaults():
    """
    Test a function with multiple arguments where only some have default values.
    In this example, the function adds two numbers, and a default is provided for 'y'.
    """
    input_schema = {
        "type": "object",
        "properties": {
            "x": {"type": "number", "scope": "public"},
            "y": {"type": "number", "scope": "public"}
        },
        "required": ["x", "y"]
    }
    output_schema = {
        "type": "object",
        "properties": {
            "result": {"type": "number", "scope": "public"}
        },
        "required": ["result"]
    }
    
    # Function that sums two numbers.
    def add(x: float, y: float) -> dict:
        return {"result": x + y}
    
    # Provide a default for 'y' only.
    tool = Tool(
        name="add",
        description="Adds two numbers",
        input_model=input_schema,
        output_model=output_schema,
        scope=Scope.PUBLIC,
        func=add,
        default_inputs={"y": 10}
    )
    
    # When only 'x' is provided, 'y' should default to 10.
    result = tool.invoke(x=5)
    assert result == {"result": 15}
    
    # When 'y' is provided explicitly, it should override the default.
    result_override = tool.invoke(x=5, y=20)
    assert result_override == {"result": 25}
